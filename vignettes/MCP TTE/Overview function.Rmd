---
title: "Test powMCT1"
author: "Carina Miller"
date: "2025-07-14"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DoseFinding, lib.loc = "~/RStudio/packages")
set.seed(123)
```




```{r}
altModels <-model1
muMat <- getResp(altModels)
muMat <- sweep(muMat, 2, muMat[1, ], "-")
muMat <- muMat[-1, , drop = FALSE]
deltaMat <- t(contMat) %*% muMat
covMat <- t(contMat) %*% S %*% contMat
den <- sqrt(diag(covMat))
deltaMat <- deltaMat/den
corMat <- cov2cor(covMat)
covMat0 <- t(contMat) %*% S0 %*% contMat
corMat0 <- cov2cor(covMat0)
critV <- critVal(corMat0, alpha, df = 0, alternative = "one.sided", control = mvtnorm.control())
res <- powCalc(alternative = "one.sided", critV, df = 0, corMat, deltaMat, control = mvtnorm.control())
```













```{r}
### S0 is under null to calculate critical value, S is under alternative
# placAdj = T, alternative = one.sided, df = Inf ist Vorausstezung:
powMCT1=function (contMat, alpha = 0.025, altModels, S, S0) 
{
  muMat <- getResp(altModels)
  muMat <- sweep(muMat, 2, muMat[1, ], "-")
  muMat <- muMat[-1, , drop = FALSE]
  deltaMat <- t(contMat) %*% muMat
  covMat <- t(contMat) %*% S %*% contMat
  den <- sqrt(diag(covMat))
  deltaMat <- deltaMat/den
  corMat <- cov2cor(covMat)
  covMat0 <- t(contMat) %*% S0 %*% contMat
  corMat0 <- cov2cor(covMat0)
  critV <- critVal(corMat0, alpha, df = 0, alternative = "one.sided", control = mvtnorm.control())
  res <- powCalc(alternative = "one.sided", critV, df = 0, corMat, deltaMat, control = mvtnorm.control())
  res}
```

critVal aus critVal1 / critVal wird genutzt fÃ¼r res aus powerCalc1 / powerCalc




```{r}
hello <- function(greeting = c("hi", "morning", "bye", "ball")){
  greeting <- match.arg(greeting)
  print(greeting)
}

hello(greeting = NULL)
```


```{r}
a <- 1
a == T
```
```{r}
love = Inf
is.finite(love)
```

```{r}
decision = function (alternative = c("one.sided", "two.sided")){
  alternative <- match.arg(alternative)
  print(alternative)
}

decision()

```

```{r}
sampSize
```

```{r}
# now assume: 
# Ntype = total
# ratio positive in all entires

function (upperN, lowerN = floor(upperN/2), targFunc, target, 
    tol = 0.001, alRatio, verbose = FALSE) 
{
    func <- function(n) {
        targFunc(n) - target
    }
    alRatio <- alRatio/sum(alRatio)
    upper <- func(round(upperN * alRatio))
  
    while (upper < 0) {
        upperN <- 2 * upperN
        upper <- func(round(upperN * alRatio))
    }
    lower <- func(round(lowerN * alRatio))
    if (lower > 0) 
        message("lower limit for sample size is decreased")
    while (lower > 0) {
        lowerN <- round(lowerN/2)
        if (lowerN == 0) 
            stop("cannot find lower limit on n")
        lower <- func(round(lowerN * alRatio))
    }
    if (verbose) {
        cat("Upper N:", upperN, "Upper value", round(upper + 
            target, 4), "\n")
        cat("Lower N:", lowerN, "Lower value", round(lower + 
            target, 4), "\n\n")
    }
    current <- tol + 1
    niter <- 0
    while (abs(current) > tol & (upperN > lowerN + 1)) {
        currN <- round((upperN + lowerN)/2)
        current <- func(round(currN * alRatio))
        if (current > 0) {
            upperN <- currN
        }
        else {
            lowerN <- currN
        }
        niter <- niter + 1
        if (verbose) {
            cat("Iter: ", niter, ", N = ", currN, ", current value = ", 
                round(current + target, 4), "\n", sep = "")
        }
    }
    while (current < 0) {
        currN <- currN + 1
        current <- func(round(currN * alRatio))
    }
    res <- list(samp.size = round(currN * alRatio), target = round(current + 
        target, 4))
    attr(res, "alRatio") <- round(alRatio/min(alRatio), 4)
    attr(res, "target") <- target
    attr(res, "Ntype") <- Ntype
    class(res) <- "sampSize"
    res
}
```

```{r}
sampSizeMCT
```

```{r}
function (upperN, lowerN = floor(upperN/2), ..., power, sumFct = mean, 
    tol = 0.001, alRatio, Ntype = c("arm", "total"), verbose = FALSE) 
{
    Ntype <- match.arg(Ntype)
    args <- list(...)
    namargs <- names(args)
    if (is.element("placAdj", namargs)) {
        if (args$placAdj) 
            stop("placAdj needs to be FALSE for sampSizeMCT.\n  Use sampSize directly in placebo-adjusted case.")
    }
    if (is.element("S", namargs)) {
        S <- args[["S"]]
        if (Ntype == "arm") {
            Ntype <- "total"
            message("Only Ntype == \"total\" possible if S is specified")
        }
        if (is.element("df", namargs)) {
            if (is.finite(args$df)) 
                message("df argument set to Inf, if S is specified.\nUse sampSize directly in case exact df are required.")
        }
        args$df <- Inf
        tFunc <- function(n) {
            N <- sum(n)
            Sn <- 1/N * S
            args$S <- Sn
            powVals <- do.call("powMCT", args)
            sumFct(powVals)
        }
    }
    else {
        if (is.element("n", namargs)) 
            stop("n is not allowed to be specified for sample size calculation")
        if (!is.element("sigma", namargs)) 
            stop("need sigma if S is not specified")
        tFunc <- function(n) {
            powVals <- powMCT(n = n, ...)
            sumFct(powVals)
        }
    }
    sampSize(upperN, lowerN, targFunc = tFunc, target = power, 
        alRatio = alRatio, Ntype = Ntype, verbose = verbose)
}
```

